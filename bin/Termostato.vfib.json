{"name":"Termostato","type":"virtual_device","properties":{"deviceIcon":1067,"currentIcon":"1066","log":"","logTemp":"","mainLoop":"--[[ termostat.linkey.es\n\tDispositivo virtual\n\tmainLoop.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n-- id de los iconos ON OFF\nlocal iconON = 1067\nlocal iconOFF = 1066\nlocal thingspeakKey = ''\n\n-- función para obtener la temperatura de la sonda virtual, escribir a\n-- continuación de 'return' el código o expresión para obtener la temperatura\nlocal virtualProbe = function (self, ...)\n  local t = fibaro:getValue(389, 'value')\n  return math.floor((t - ((41 - t) / t)) * 100) / 100\nend\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal release = {name='termostatoVirtual', ver=2, mayor=0, minor=0}\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal mode = {}; mode[0]='OFF'; mode[1]='AUTO'; mode[2]='MANUAL'\nmode[3]='CALIBRADO_F1'; mode[4]='CALIBRADO_F2'; mode[5]='CALIBRADO_FIN'\nOFF=1;INFO=2;DEBUG=3                -- referencia para el log\nnivelLog = INFO                    -- nivel de log\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n--[[toolKit\nConjunto de funciones para compartir en varios proyectos --]]\nif not toolKit then toolKit = {\n  __version = \"1.0.1\",\n  -- log(level, log)\n  -- (global) level: nivel de LOG\n  -- (string) mensaje: mensaje\n  log = (\n  function(self, level, mensaje, ...)\n    if not mensaje then mensaje = 'nil' end\n    if nivelLog >= level then\n      local color = 'yellow'\n      if level == INFO then color = 'green' end\n      fibaro:debug(string.format(\n      '<%s style=\"color:%s;\">%s</%s>', \"span\", color, mensaje, \"span\")\n      )\n    end\n  end),\n  calculatePID = (\n  --[[calculatePID()\n    (table) PID:  tabla que representa el estado actual del PID\n    Calcula el PID y lo devuelve una tabla que lo representa\n    Tabla PID:\n    {result = 0, newErr = 0, acumErr = 0, proporcional = 0,\n    integral = 0, derivativo = 0, lastInput = 0, value = 0, targetLevel = 0,\n    kP = 250, kI = 50, kD = 25, cyclesH = 12, antiwindupReset = 1, tuneTime = 0,\n    checkPoint = 0, changePoint = 0, minTimeAction = 30, secureTimeAction = 0,\n    histeresis = 0.1}\n    --]]\n  function(self, PID, ...)\n    toolKit:log(INFO, '----- calculatePID v2.0 -----------------------------')\n    -- calcular error\n    PID.newErr = PID.targetLevel - PID.value\n\n    -- calcular proporcional y si es negativo dejarlo a cero\n    PID.proporcional = PID.newErr * PID.kP\n    if PID.proporcional < 0 then\n      PID.proporcional = 0\n      toolKit:log(INFO, 'proporcional < 0')\n    end\n\n    -- anti derivative kick usar el inverso de (currentTemp - lastInput) en\n    -- lugar de error\n    PID.derivativo = ((PID.value - PID.lastInput) * PID.kD) * - 1\n\n    --[[reset del antiwindup\n    si el error no esta comprendido dentro del ámbito de actuación del\n    integrador, no se usa el cálculo integral y se acumula error = 0]]\n    if math.abs(PID.newErr) > PID.antiwindupReset then\n      PID.integral = 0\n      PID.acumErr = 0\n      toolKit:log(INFO, 'reset antiwindup del integrador ∓'..PID.antiwindupReset)\n\n    --[[uso normal del integrador\n    se calcula el resultado con el error acumulado anterior y se acumula el\n    error actual al error anterior]]\n    else\n      -- calcular integral\n      PID.integral = PID.acumErr * PID.kI\n      PID.acumErr = PID.acumErr + PID.newErr\n    end\n\n    --[[antiwindup del integrador\n    si el cálculo integral es mayor que el tiempo de ciclo, se ajusta el\n    resultado al tiempo de ciclo y no se acumula el error]]\n    if PID.integral > (3600 / PID.cyclesH) then\n      PID.integral = (3600 / PID.cyclesH)\n      toolKit:log(INFO, 'antiwindup del integrador > '..(3600 / PID.cyclesH))\n    end\n\n    -- calcular salida\n    PID.result = PID.proporcional + PID.integral + PID.derivativo\n\n    --[[antiwindup de la salida\n    si el resultado es mayor que el que el tiempo de ciclo, se ajusta el\n    resultado al tiempo de ciclo menos tiempo de seguridad y no se acumula el\n    error --]]\n    if PID.result >= (3600 / PID.cyclesH) then\n      -- al menos apgar tiempo mínimo\n      PID.result = (3600 / PID.cyclesH) - PID.secureTimeAction\n      toolKit:log(INFO, 'antiwindup salida > '..(3600 / PID.cyclesH) -\n       PID.secureTimeAction)\n    elseif PID.result < 0 then\n      PID.result = 0\n      toolKit:log(INFO, 'antiwindup salida < 0')\n    end\n\n    --[[limitador por histeresis\n    si error es menor o igual que la histeresis limitar la salida a 0, siempre\n    que la tempeatura venga subiendo, no limitar hiteresis de bajada. Resetear\n    el error acumulado. Si no hacemos esto tenemos acciones de control de la\n    parte integral muy altas debidas a un error acumulado grande cuando estamos\n    en histéresis. Eso provoca acciones integrales diferidas muy grandes]]\n    if PID.result > 0 and math.abs(PID.newErr) <= PID.histeresis then\n      PID.acumErr = 0\n      if PID.lastInput < PID.value then -- solo de subida\n        PID.result = 0\n        toolKit:log(INFO, 'histéresis error ∓'..PID.histeresis)\n      end\n    end\n\n    --[[límitador de acción mínima\n    si el resultado es menor que el tiempo mínimo de acción, ajustar a 0.\n    si se va a encender menos del tiempo mínimo, no encender]]\n    if (PID.result <= math.abs(PID.minTimeAction)) and (PID.result ~= 0) then\n      PID.result = 0\n      toolKit:log(INFO, 'tiempo salida ∓'..PID.minTimeAction)\n      --[[si se va a apgar menos de tiempo de seguridad no apagar]]\n    elseif PID.result > ((3600 / PID.cyclesH) - PID.secureTimeAction) then\n      PID.result = (3600 / PID.cyclesH) - PID.secureTimeAction\n    end\n\n    -- informar\n    toolKit:log(INFO, 'E='..PID.newErr..', P='..PID.proporcional..', I='..\n    PID.integral..', D='..PID.derivativo..', S='..PID.result)\n\n    -- recordar algunas variables para el proximo ciclo SE conservan en el PID\n    --result, lastInput, acumErr = PID.result, termostatoVirtual.value,\n    --PID.acumErr\n    PID.lastInput = PID.value\n    -- ajustar el punto de cambio de estado de la Caldera\n    PID.changePoint = os.time() + PID.result\n    -- ajustar el punto de próximo cálculo\n    PID.checkPoint = os.time() + (3600 / PID.cyclesH)\n    -- añadir tiemstamp al PID\n    PID.timestamp = os.time()\n\n    -- informar\n    toolKit:log(INFO, 'Error acumulado: '..PID.acumErr)\n    toolKit:log(INFO, '-------------------------------------------------------')\n\n    -- devolver PID\n    return PID\n  end)\n} end\n\n--[[isVariable(varName)\n    (string) varName: nombre de la variable global\n  comprueba si existe una variable global dada(varName) --]]\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[resetDevice(nodeId)\n    (number) nodeId: número del dispositivo a almacenar en la variable global\n  crea una varaible global para almacenar la tabla que representa el dispositivo\n  y lo inicializa. --]]\nfunction resetDevice(nodeId)\n  -- si no exite la variable global\n  if not isVariable('dev'..nodeId) then\n    -- intentar crear la variableGlobal\n    local json = '{\"name\":\"'..'dev'..nodeId..'\", \"isEnum\":0}'\n    if not HC2 then HC2 = Net.FHttp(\"127.0.0.1\", 11111) end\n    HC2:POST(\"/api/globalVariables\", json)\n    fibaro:sleep(1000)\n    -- comprobar que se ha creado la variableGlobal\n    if not isVariable('dev'..nodeId) then\n      toolKit:log(DEBUG, 'No se pudo declarar variable global '..'dev'..nodeId)\n      fibaro:abort()\n    end\n  end\n  -- crear tabla vacía para dispositivo\n  -- el dispositivo tiene un PID\n  local PID = {result = 0, newErr = 0, acumErr = 0, proporcional = 0,\n   integral = 0, derivativo = 0, lastInput = 0, value = 0, targetLevel = 0,\n   kP = 250, kI = 50, kD = 25, cyclesH = 12, antiwindupReset = 1, tuneTime = 0,\n   checkPoint = 0, changePoint = 0, minTimeAction = 30, secureTimeAction = 15,\n   histeresis = 0.1}\n\n  local actuator = {id = 0, name = '', onFunction = '', offFunction = '',\n   statusPropertie = '', maintenance = true}\n\n  local termostatoVirtual = {PID = PID, actuator = actuator, nodeId = nodeId,\n   panelId = 0, probeId = 0, targetLevel = 0, value = 0, mode = 1,\n   timestamp = os.time(), oN = false}\n  -- guardar la tabla en la variable global\n  fibaro:setGlobal('dev'..nodeId, json.encode(termostatoVirtual))\n  return termostatoVirtual\nend\n\n--[[getDevice(nodeId)\n    (number) nodeId: número del dispositivo a recuperar de la variable global\n  recupera el dispositivo virtual desde la variable global --]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device and device ~= 'NaN' and device ~= 0 and device ~= '' then\n    device = json.decode(device)\n    -- si esta iniciado devolver el dispositivo\n    if device.nodeId then\n      toolKit:log(DEBUG, 'nodeId: '..device.nodeId)\n      return device\n     end\n  end\n  -- en cualquier otro caso iniciarlo y devolverlo\n  return resetDevice(nodeId)\nend\n\n--[[getPanel(roomId)\n    (number) nodeId: número del dispositivo a almacenar en la variable global\n  devuelve el panel de calefacción que controla la habitación donde se encuentra\n  el disposito virtual con identificador nodeId --]]\nfunction getPanel(roomId)\n  toolKit:log(DEBUG, 'roomId: '..roomId)\n  -- obtener paneles de temperatura\n  if not HC2 then HC2 = Net.FHttp(\"127.0.0.1\", 11111) end\n  response ,status, errorCode = HC2:GET(\"/api/panels/heating\")\n  -- recorrer la tabla de paneles y buscar si alguno controla esta habitación\n  local panels = json.decode(response)\n  for pKey, pValue in pairs(panels) do\n    toolKit:log(DEBUG, 'Panel: '..pValue.id)\n    -- obtener panel\n    if not HC2 then HC2 = Net.FHttp(\"127.0.0.1\", 11111) end\n    response ,status, errorCode = HC2:GET(\"/api/panels/heating/\"..pValue.id)\n    local panel = json.decode(response)\n    local rooms = panel['properties'].rooms\n    -- recorrer las habitaciones de cada panel\n    for rKey, rValue in pairs(rooms) do\n      toolKit:log(DEBUG, 'Room: '..rValue)\n      if rValue == roomId then return panel end\n    end\n  end\n  return false\nend\n\n--[[getTargetLevel(panel)\n    (table) panel: tabla que representa un panel de temperatura\n  devuelve la temperatura de consigna desde panel indicado\n--]]\nfunction getTargetLevel(panel)\n  -- obtener propiedades del panel\n  local properties = panel.properties\n\n  -- si vacationTemperature ~= 0 devolver \"vacationTemperature\"\n  if properties.vacationTemperature ~= 0 then\n    return properties.vacationTemperature\n  end\n\n  -- si handTimestamp >= os.time() devolver \"handTemperature\"\n  if properties.handTimestamp >= os.time() then\n    return properties.handTemperature\n  end\n\n  -- en otro caso devolver \"temperature\"\n  -- obtener dia de la semana de hoy\n  local dow = string.lower(tostring(os.date('%A')))\n  toolKit:log(DEBUG, 'Hoy es: '..dow)\n  -- obtener la tabla con propiedades del día de la semana\n  local todayTab = properties[dow]\n\n  -- obtenr día de la semana de fue ayer\n  dow = string.lower(tostring(os.date('%A', os.time() - 24*60*60 )))\n  toolKit:log(DEBUG, 'Ayer fue: '..dow)\n  -- obtener tabla con propiedades de ayer\n  local yesterdayTab = properties[dow]\n  -- obtener la temperatura de la noche de ayer para poder usarla como posible\n  -- temperatura, si la hora actual es anteriror a la de la mañana del panel,\n  -- hay que tomar la de la noche del día anteriror.\n  local temperatura = yesterdayTab['night'].temperature\n  toolKit:log(DEBUG, 'Temperatura ayer noche: '..temperatura)\n\n  -- las partes en las que divide el día el panel\n  local states = {'morning', 'day', 'evening', 'night'}\n  local year, month, day = os.date('%Y'), os.date('%m'), os.date('%d')\n  toolKit:log(DEBUG, os.time())\n  -- inicialmete tomar como temperatura la última temperatura del día anteriror.\n  -- recorrer los diferentes partes en las que divide el día en panel y comparar\n  -- el timestamp de cada una de ellas con el timestamp actual, si el actual es\n  -- mayor o igual se va tomando la temperatura de esa parte.\n  for key, value in pairs(states) do\n    local hour = todayTab[value].hour\n    local min = todayTab[value].minute\n    toolKit:log(DEBUG, hour..':'..min)\n    local timestamp =\n     os.time{year = year, month = month, day = day, hour = hour, min = min}\n    toolKit:log(DEBUG, timestamp)\n    if os.time() >= timestamp then\n      temperatura = todayTab[value].temperature\n    else\n      break\n    end\n  end\n  -- devolver la temperatura que corresponde en el panel en este momento\n  return temperatura\nend\n\n--[[setActuador(actuator, start)\n    (table)  actuator: tabla que representa un actuador\n    (boolean) start: encender = true, apagar = false\n  ordena el apagado/encendido a un actuador, este solo opera si la orden es\n  contraria al estado actual de actuador --]]\nfunction setActuador(actuator, start)\n  -- si el actuador no está en modo mantenimiento\n  toolKit:log(DEBUG, actuator.id)\n  if actuator.id and actuator.id ~= 0 and not actuator.maintenance then\n    -- comprobar estado actual\n    local actuatorState = fibaro:getValue(actuator.id, actuator.statusPropertie)\n    toolKit:log(DEBUG, 'Actuador : '..actuator.id..' con estado : '..\n     actuatorState)\n    -- si hay que encender y esta apagado\n    if start and actuatorState == '0' then\n      -- informar\n      toolKit:log(INFO, 'Actuador-ON')\n      fibaro:call(actuator.id, actuator.onFunction, 1)\n    end\n    -- si hay que apagar y está encendido\n    if not start and actuatorState == '1' then\n      -- informar\n      toolKit:log(INFO, 'Actuador-OFF')\n      fibaro:call(actuator.id, actuator.offFunction, 0)\n    end\n  end\nend\n\n--[[updateStatistics(PID, thingspeakKey)\n  (table)   PID:  tabla que representa el PID\n  (string)  thingspeakKey:  cadena con la Key del canal de thingspeakKey\n  actualiza los valores en thingspeak --]]\nfunction updateStatistics(PID, thingspeakKey)\n  -- analizar resultado\n  toolKit:log(DEBUG, 'E='..PID.newErr..', P='..PID.proporcional..', I='..\n   PID.integral..', D='..PID.derivativo..', S='..PID.result)\n  --timestampPID = termostatoVirtual.PID['timestamp']\n  if not thingspeak then\n    thingspeak = Net.FHttp(\"api.thingspeak.com\")\n  end\n  local payload = \"key=\"..thingspeakKey..\"&field1=\"..PID.newErr..\n  \"&field2=\"..PID.proporcional..\"&field3=\"..PID.integral..\n  \"&field4=\"..PID.derivativo..\"&field5=\"..PID.result..\n  \"&field6=\"..PID.targetLevel..\"&field7=\"..PID.value\n  local response, status, errorCode = thingspeak:POST('/update', payload)\nend\n\n-- actualizar etiqueta identificador\nfibaro:call(_selfId, \"setProperty\", \"ui.labelId.value\",'id: '.._selfId)\n\n--[[--------- BUCLE PRINCIPAL ------------------------------------------------]]\nwhile true do\n  -- recuperar dispositivo\n  local termostatoVirtual = getDevice(_selfId)\n  toolKit:log(DEBUG, 'termostatoVirtual: '..json.encode(termostatoVirtual))\n\n  --[[Panel]]\n  -- obtener el panel\n  local panel = getPanel(fibaro:getRoomID(_selfId))\n  -- si hay panel de calefacción para la habitación donde está el termostato\n  if panel then\n    toolKit:log(DEBUG, 'Nombre panel: '..panel.name)\n    -- actualizar identificador del panel\n    termostatoVirtual.panelId = panel.id\n  else -- si no hay panel\n    -- cambiar el modo a MANUAL y el identificador de panel a 0\n    termostatoVirtual.panelId = 0\n  end\n\n  --[[temperarura actual]]\n  -- si hay sonda declarada obtener la temperatura\n  if termostatoVirtual.probeId and termostatoVirtual.probeId ~= 0 then\n    termostatoVirtual.value  =\n    tonumber(fibaro:getValue(termostatoVirtual.probeId, 'value'))\n  elseif termostatoVirtual.probeId == 0 then\n    -- si la sonda es virtual\n    termostatoVirtual.value  = virtualProbe()\n  end\n\n  --[[temperarura de consigna]]\n  -- comparar timestamp con os.time() y comprobar si hay panel\n  if (termostatoVirtual.timestamp < os.time())\n   and termostatoVirtual.panelId ~= 0\n   and termostatoVirtual.mode ~= 0 then\n    -- si es menor y status es AUTOMATICO, tomar temperatura del panel\n    termostatoVirtual.targetLevel = getTargetLevel(panel)\n    toolKit:log(DEBUG, 'Temperatura consigna: '..\n    termostatoVirtual.targetLevel..'ºC')\n  end\n\n  --[[tiempo de protección]]\n  -- si el modo no es OFF ni calibrando OFF=0 CALIBRANDO>=3\n  if termostatoVirtual.mode > 0 and termostatoVirtual.mode < 3 then\n    local shadowTime = termostatoVirtual.timestamp - os.time()\n    -- si ha finalizado el tiempo de proteccion y hay panel\n    if shadowTime <= 0 and termostatoVirtual.panelId ~= 0 then\n      shadowTime = 0\n      -- actualizar el modo de funcionamiento a AUTOMATICO\n      termostatoVirtual.mode = 1\n    else\n      shadowTime = shadowTime / 60\n      -- actualizar el modo de funcionamiento a MANUAL\n      termostatoVirtual.mode = 2\n    end\n    -- actualizar etiqueda de modo de funcionamiento \"mode\"\"\n    toolKit:log(DEBUG, 'Modo: '..mode[termostatoVirtual.mode])\n    fibaro:call(_selfId, \"setProperty\", \"ui.modeLabel.value\",\n     mode[termostatoVirtual.mode])\n     -- actualizar etiqueta de tiempo\n    local minText = {}; local timeLabel = '06h 00m'\n    minText[0]   = '00h 00m'; minText[15]  = '00h 15m'; minText[30]  = '00h 30m'\n    minText[45]  = '00h 45m'; minText[60]  = '01h 00m'; minText[75]  = '01h 15m'\n    minText[90]  = '01h 30m'; minText[105] = '01h 45m'; minText[120] = '02h 00m'\n    minText[135] = '02h 15m'; minText[150] = '02h 30m'; minText[165] = '02h 45m'\n    minText[180] = '03h 00m'; minText[195] = '03h 15m'; minText[210] = '03h 30m'\n    minText[225] = '03h 45m'; minText[240] = '04h 00m'; minText[255] = '04h 15m'\n    minText[270] = '04h 30m'; minText[285] = '04h 45m'; minText[300] = '05h 00m'\n    minText[315] = '05h 15m'; minText[330] = '05h 30m'; minText[345] = '05h 45m'\n    minText[360] = '06h 00m'\n    for value = 360, 0, -15 do\n      if shadowTime <= value then\n        timeLabel = minText[value]\n      else\n        break\n      end\n    end\n    -- actualizar etiqueta de tiempo\n    fibaro:call(_selfId, \"setProperty\", \"ui.timeLabel.value\", timeLabel)\n  else\n    -- actualizar etiqueda de modo de funcionamiento \"mode\"\n    fibaro:call(_selfId, \"setProperty\", \"ui.modeLabel.value\",\n     mode[termostatoVirtual.mode])\n  end\n\n  -- guardar los cambios del dispositivo termostatoVirtual\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- si se ha cumplido el ciclo o si ha cambiado la consigna, calcular el PID\n  if os.time() >= termostatoVirtual['PID'].checkPoint or\n  termostatoVirtual.targetLevel ~= termostatoVirtual['PID'].targetLevel then\n    -- asgnar la consgna y la temperatura actual\n    termostatoVirtual['PID'].targetLevel = termostatoVirtual.targetLevel\n    termostatoVirtual['PID'].value = termostatoVirtual.value\n    -- actualizar dispositivo\n    termostatoVirtual.PID = toolKit:calculatePID(termostatoVirtual.PID)\n    -- actualizar estadísticas\n    updateStatistics(termostatoVirtual.PID, thingspeakKey)\n    -- guardar el nuevo PID\n    fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n    -- recuperar dispositivo\n    termostatoVirtual = getDevice(termostatoVirtual.nodeId)\n  end\n\n  --[[encendido / apagado\n  si os.time() menor que el punto de cambio \"changePoint\" APAGADO\n  si os.time() mayor o igual al punto de cambio, ENCENDIDO--]]\n  if os.time() < termostatoVirtual['PID'].changePoint then\n    -- informar\n    toolKit:log(DEBUG, 'ON')\n    -- anotar\n    termostatoVirtual.oN = true\n    -- actuar sobre el actuador si es preciso\n    setActuador(termostatoVirtual.actuator, true)\n  else\n    -- informar\n    toolKit:log(DEBUG, 'OFF')\n    -- anotar\n    termostatoVirtual.oN = false\n    -- actuar sobre el actuador si es preciso\n    setActuador(termostatoVirtual.actuator, false)\n  end\n  -- guardar nuevo estado oNoFf\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- actualizar icono y etiquetas\n  local onOff = ' _'\n  local icono = iconOFF\n  if termostatoVirtual.oN then\n    onOff = ' 🔥'\n    icono = iconON\n  end\n  local targetLevel = string.format('%.2f', termostatoVirtual.targetLevel)\n  local value = string.format('%.2f', termostatoVirtual.value )\n  -- actualizar etiqueta\n  fibaro:call(_selfId, \"setProperty\", \"ui.actualConsigna.value\",\n   value..'ºC / '..targetLevel..'ºC'..onOff)\n  -- actualizar icono\n  fibaro:call(_selfId, 'setProperty', \"currentIcon\", icono)\n\n  -- esperar para evitar colapsar la CPU\n  fibaro:sleep(1000)\n  -- para control por watchdog\n  toolKit:log(INFO, release['name']..' OK')\nend\n\n--[[--------- FIN BUCLE PRINCIPAL 🌛🔧🌡🔥🔘⏱📈 📟⚙-----------------------]]\n","ui.actualConsigna.value":"22.31ºC / 21.00ºC _","ui.labelId.value":"id: 638","ui.modeLabel.value":"AUTO","ui.timeLabel.value":"00h 00m","visible":"true","rows":[{"type":"label","elements":[{"id":1,"lua":false,"waitForResponse":false,"caption":"","name":"actualConsigna","favourite":false,"main":true}]},{"type":"label","elements":[{"id":2,"lua":false,"waitForResponse":false,"caption":"","name":"timeLabel","favourite":false,"main":false}]},{"type":"button","elements":[{"id":3,"lua":true,"waitForResponse":false,"caption":"-🌡","name":"downTempButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tdownTempButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal intervalo = 0.1\nlocal maxTemp = 28\nlocal shadowTime = 120 -- minutos en intervalos de 15min.\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  -- recuperar temperaturas\n  local value = termostatoVirtual.value\n  local targetLevel = termostatoVirtual.targetLevel\n  local onOff = ' _'\n  -- disminuir intervalo\n  if targetLevel >= intervalo then\n    targetLevel = targetLevel - intervalo\n  else\n    targetLevel = maxTemp\n  end\n\n  --actualizar dispositivo\n  termostatoVirtual.targetLevel = targetLevel\n  -- proteger con un tiempo por defecto\n  termostatoVirtual.timestamp = os.time() + shadowTime * 60\n  -- guardar en variable global\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- actualizar la etiqueta\n  targetLevel = string.format('%.2f', targetLevel)\n  value = string.format('%.2f', value)\n  local onOff = ' _'\n  fibaro:call(_selfId, \"setProperty\", \"ui.actualConsigna.value\",\n   value..'ºC / '..targetLevel..'ºC'..onOff)\nend\n\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":true},{"id":4,"lua":true,"waitForResponse":false,"caption":"+🌡","name":"upTempButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tupTempButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal intervalo = 0.1\nlocal maxTemp = 28\nlocal shadowTime = 120 -- minutos en intervalos de 15min.\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  -- recuperar temperaturas\n  local value = termostatoVirtual.value\n  local targetLevel = termostatoVirtual.targetLevel\n  local onOff = ' _'\n  -- disminuir intervalo\n  if targetLevel <= (maxTemp - intervalo) then\n    targetLevel = targetLevel + intervalo\n  else\n    targetLevel = 0\n  end\n\n  --actualizar dispositivo\n  termostatoVirtual.targetLevel = targetLevel\n  -- proteger con un tiempo por defecto\n  termostatoVirtual.timestamp = os.time() + shadowTime * 60\n  -- guardar en variable global\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- actualizar la etiqueta\n  targetLevel = string.format('%.2f', targetLevel)\n  value = string.format('%.2f', value)\n  local onOff = ' _'\n  fibaro:call(_selfId, \"setProperty\", \"ui.actualConsigna.value\",\n   value..'ºC / '..targetLevel..'ºC'..onOff)\nend\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false},{"id":5,"lua":true,"waitForResponse":false,"caption":"🌛","name":"ecoButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tecoButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal mode = {}; mode[0]='OFF'; mode[1]='AUTO'; mode[2]='MANUAL'\nlocal ecoTemperature = 18 -- ºC\nlocal shadowTime = 360\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  --actualizar dispositivo\n  termostatoVirtual.timestamp = os.time() + shadowTime * 60\n  termostatoVirtual.targetLevel = ecoTemperature\n  -- guardar en variable global\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\nend\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false},{"id":6,"lua":true,"waitForResponse":false,"caption":"☀️/❄️","name":"onOffButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tonOffButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal mode = {}; mode[0]='OFF'; mode[1]='AUTO'; mode[2]='MANUAL'\nlocal offTemperature = 5 -- ºC\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- --actualizar dispositivo\nif termostatoVirtual.mode == 0 then\n\ttermostatoVirtual.mode = 1\n  termostatoVirtual.timestamp = os.time()\nelse\n\ttermostatoVirtual.mode = 0\n\ttermostatoVirtual.targetLevel = offTemperature\nend\n-- guardar en variable global\nfibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n-- actualizar etiqueda de modo de funcionamiento \"mode\"\"\nfibaro:call(_selfId, \"setProperty\", \"ui.modeLabel.value\",\n mode[termostatoVirtual.mode])\n\nfibaro:debug(mode[termostatoVirtual.mode])\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"button","elements":[{"id":7,"lua":true,"waitForResponse":false,"caption":"--🌡","name":"downDownTempButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tdownTempButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal intervalo = 0.5\nlocal maxTemp = 28\nlocal shadowTime = 120 -- minutos en intervalos de 15min.\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  -- recuperar temperaturas\n  local value = termostatoVirtual.value\n  local targetLevel = termostatoVirtual.targetLevel\n  local onOff = ' _'\n  -- disminuir intervalo\n  if targetLevel >= intervalo then\n    targetLevel = targetLevel - intervalo\n  else\n    targetLevel = maxTemp\n  end\n\n  --actualizar dispositivo\n  termostatoVirtual.targetLevel = targetLevel\n  -- proteger con un tiempo por defecto\n  termostatoVirtual.timestamp = os.time() + shadowTime * 60\n  -- guardar en variable global\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- actualizar la etiqueta\n  targetLevel = string.format('%.2f', targetLevel)\n  value = string.format('%.2f', value)\n  local onOff = ' _'\n  fibaro:call(_selfId, \"setProperty\", \"ui.actualConsigna.value\",\n   value..'ºC / '..targetLevel..'ºC'..onOff)\nend\n\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false},{"id":8,"lua":true,"waitForResponse":false,"caption":"++🌡","name":"upUpTempButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tupTempButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\nlocal intervalo = 0.5\nlocal maxTemp = 28\nlocal shadowTime = 120 -- minutos en intervalos de 15min.\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  -- recuperar temperaturas\n  local value = termostatoVirtual.value\n  local targetLevel = termostatoVirtual.targetLevel\n  local onOff = ' _'\n  -- disminuir intervalo\n  if targetLevel <= (maxTemp - intervalo) then\n    targetLevel = targetLevel + intervalo\n  else\n    targetLevel = 0\n  end\n\n  --actualizar dispositivo\n  termostatoVirtual.targetLevel = targetLevel\n  -- proteger con un tiempo por defecto\n  termostatoVirtual.timestamp = os.time() + shadowTime * 60\n  -- guardar en variable global\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\n\n  -- actualizar la etiqueta\n  targetLevel = string.format('%.2f', targetLevel)\n  value = string.format('%.2f', value)\n  local onOff = ' _'\n  fibaro:call(_selfId, \"setProperty\", \"ui.actualConsigna.value\",\n   value..'ºC / '..targetLevel..'ºC'..onOff)\nend\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false},{"id":9,"lua":true,"waitForResponse":false,"caption":"- ⏱","name":"downTimeButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tdownTimeButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  -- tablas de tiempo a texto y texto a tiempo en intervalos de 15min.\n  local textMin = {}\n  textMin['00h 00m']   = 0; textMin['00h 15m']  = 15; textMin['00h 30m']  = 30\n  textMin['00h 45m']  = 45; textMin['01h 00m']  = 60; textMin['01h 15m']  = 75\n  textMin['01h 30m']  = 90; textMin['01h 45m'] = 105; textMin['02h 00m'] = 120\n  textMin['02h 15m'] = 135; textMin['02h 30m'] = 150; textMin['02h 45m'] = 165\n  textMin['03h 00m'] = 180; textMin['03h 15m'] = 195; textMin['03h 30m'] = 210\n  textMin['03h 45m'] = 225; textMin['04h 00m'] = 240; textMin['04h 15m'] = 255\n  textMin['04h 30m'] = 270; textMin['04h 45m'] = 285; textMin['05h 00m'] = 300\n  textMin['05h 15m'] = 315; textMin['05h 30m'] = 330; textMin['05h 45m'] = 345\n  textMin['06h 00m'] = 360\n  local minText = {}\n  minText[0]   = '00h 00m'; minText[15]  = '00h 15m'; minText[30]  = '00h 30m'\n  minText[45]  = '00h 45m'; minText[60]  = '01h 00m'; minText[75]  = '01h 15m'\n  minText[90]  = '01h 30m'; minText[105] = '01h 45m'; minText[120] = '02h 00m'\n  minText[135] = '02h 15m'; minText[150] = '02h 30m'; minText[165] = '02h 45m'\n  minText[180] = '03h 00m'; minText[195] = '03h 15m'; minText[210] = '03h 30m'\n  minText[225] = '03h 45m'; minText[240] = '04h 00m'; minText[255] = '04h 15m'\n  minText[270] = '04h 30m'; minText[285] = '04h 45m'; minText[300] = '05h 00m'\n  minText[315] = '05h 15m'; minText[330] = '05h 30m'; minText[345] = '05h 45m'\n  minText[360] = '06h 00m'\n\n  -- recuperar etiqueta de tiempo\n  local time = textMin[fibaro:get(_selfId, 'ui.timeLabel.value')]\n  -- disminuir 15min\n  if time > 0 then time = time - 15 else time = 360 end\n\n  -- actualizar la etiqueta\n  fibaro:call(_selfId, \"setProperty\", \"ui.timeLabel.value\", minText[time])\n  -- recuperar dispositivo\n  termostatoVirtual = getDevice(_selfId)\n  --actualizar dispositivo\n  termostatoVirtual.timestamp = os.time() + time * 60\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\nend\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false},{"id":10,"lua":true,"waitForResponse":false,"caption":"+ ⏱","name":"upTimeButton","empty":false,"msg":"--[[ TermostatoVirtual\n\tDispositivo virtual\n\tupTimeButton.lua\n\tpor Manuel Pascual\n------------------------------------------------------------------------------]]\n\n--[[----- CONFIGURACION DE USUARIO -------------------------------------------]]\n--[[----- FIN CONFIGURACION DE USUARIO ---------------------------------------]]\n\n--[[----- NO CAMBIAR EL CODIGO A PARTIR DE AQUI ------------------------------]]\n\n--[[----- CONFIGURACION AVANZADA ---------------------------------------------]]\nlocal _selfId = fibaro:getSelfId()  -- ID de este dispositivo virtual\n--[[----- FIN CONFIGURACION AVANZADA -----------------------------------------]]\n\n-- isVariable(varName)\n-- (string) varName: nombre de la variable global\n-- comprueba si existe una variable global dada\nfunction isVariable(varName)\n  -- comprobar si existe\n  local valor, timestamp = fibaro:getGlobal(varName)\n  if (valor and timestamp > 0) then return valor end\n  return false\nend\n\n--[[----------------------------------------------------------------------------\ngetDevice(nodeId)\n\trecupera el dispositivo virtual desde la variable global\n  (number)\n--]]\nfunction getDevice(nodeId)\n  -- si  exite la variable global recuperar dispositivo\n  local device = isVariable('dev'..nodeId)\n  if device then\n    return json.decode(device)\n  end\nend\n\n-- recuperar dispositivo\nlocal termostatoVirtual = getDevice(_selfId)\n\n-- comprobar que no está en modo MANUAL\nif termostatoVirtual.mode ~= 0 then\n  local textMin = {}\n  textMin['00h 00m']   = 0; textMin['00h 15m']  = 15; textMin['00h 30m']  = 30\n  textMin['00h 45m']  = 45; textMin['01h 00m']  = 60; textMin['01h 15m']  = 75\n  textMin['01h 30m']  = 90; textMin['01h 45m'] = 105; textMin['02h 00m'] = 120\n  textMin['02h 15m'] = 135; textMin['02h 30m'] = 150; textMin['02h 45m'] = 165\n  textMin['03h 00m'] = 180; textMin['03h 15m'] = 195; textMin['03h 30m'] = 210\n  textMin['03h 45m'] = 225; textMin['04h 00m'] = 240; textMin['04h 15m'] = 255\n  textMin['04h 30m'] = 270; textMin['04h 45m'] = 285; textMin['05h 00m'] = 300\n  textMin['05h 15m'] = 315; textMin['05h 30m'] = 330; textMin['05h 45m'] = 345\n  textMin['06h 00m'] = 360\n  local minText = {}\n  minText[0]   = '00h 00m'; minText[15]  = '00h 15m'; minText[30]  = '00h 30m'\n  minText[45]  = '00h 45m'; minText[60]  = '01h 00m'; minText[75]  = '01h 15m'\n  minText[90]  = '01h 30m'; minText[105] = '01h 45m'; minText[120] = '02h 00m'\n  minText[135] = '02h 15m'; minText[150] = '02h 30m'; minText[165] = '02h 45m'\n  minText[180] = '03h 00m'; minText[195] = '03h 15m'; minText[210] = '03h 30m'\n  minText[225] = '03h 45m'; minText[240] = '04h 00m'; minText[255] = '04h 15m'\n  minText[270] = '04h 30m'; minText[285] = '04h 45m'; minText[300] = '05h 00m'\n  minText[315] = '05h 15m'; minText[330] = '05h 30m'; minText[345] = '05h 45m'\n  minText[360] = '06h 00m'\n\n  -- recuperar etiqueta de tiempo\n  local time = textMin[fibaro:get(_selfId, 'ui.timeLabel.value')]\n  -- aumentar 15min\n  if time < 360 then time = time + 15 else time = 0 end\n\n  -- actualizar la etiqueta\n  fibaro:call(_selfId, \"setProperty\", \"ui.timeLabel.value\", minText[time])\n  -- recuperar dispositivo\n  termostatoVirtual = getDevice(_selfId)\n  --actualizar dispositivo\n  termostatoVirtual.timestamp = os.time() + time * 60\n  fibaro:setGlobal('dev'.._selfId, json.encode(termostatoVirtual))\nend\n--[[--------------------------------------------------------------------------]]\n","buttonIcon":0,"favourite":false,"main":false}]},{"type":"label","elements":[{"id":11,"lua":false,"waitForResponse":false,"caption":"Modo:","name":"modeLabel","favourite":false,"main":false}]},{"type":"label","elements":[{"id":12,"lua":false,"waitForResponse":false,"caption":"","name":"labelId","favourite":false,"main":false}]}]},"actions":{"pressButton":1,"setSlider":2,"setProperty":2}}